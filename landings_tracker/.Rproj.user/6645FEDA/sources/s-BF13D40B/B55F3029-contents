.libPaths(c("/usr/lib64/R/shiny_library/fisheye", .libPaths()))

library(jsonlite)
library(shiny)
library(ggplot2)
library(DT)
library(plotly)
library(shinyWidgets)
library(dplyr)
library(data.table)
library(lubridate)

comp_dat_covid_app <- readRDS("comp_dat_covidapp.RDS") %>%
  mutate(complete = case_when(is.na(complete) ~ 'complete',
                              T ~ complete)) %>%
  data.table()
setkey(comp_dat_covid_app, State, Species)
# split up the month and other filters befor joining to reduce size of df 
addlfilters <- readRDS("addlfilters.RDS")
month_filter <- select(addlfilters, State, Species, month_prop, select_month) %>%
  data.table()
setkey(month_filter, State, Species)
othr_filter <- select(addlfilters, -c(month_prop, select_month)) %>% distinct() %>%
  data.table()
setkey(othr_filter, State, Species)
# lists of things to speed everything up

list_of_metrics <- unique(comp_dat_covid_app$Metric)
list_of_species <- levels(comp_dat_covid_app$Species)
list_of_stats <- unique(comp_dat_covid_app$Statistic)
# state_max <- ceiling(max(addlfilters$state_prop))
# month_max <- ceiling(max(addlfilters$month_prop))
# 
# perc_min <-  floor(min(addlfilters$percchange, na.rm = T))
# perc_max <- ceiling(max(addlfilters$percchange, na.rm = T))

# Data formatting for plot ####
# data with month filter
data_m <- month_filter[comp_dat_covid_app, on = c('State','Species'), allow.cartesian = T] %>%
  data.table()

# data with other filters
data <- othr_filter[comp_dat_covid_app, on = c('State','Species')] %>%
  data.table()

# Data formatting for table#####
# data with month filter
data_table_m <- data_m[, `:=` (Value = round(Value, 2),
                       Variance = round(Variance, 2),
                       q25 = round(q25, 2),
                       q75 = round(q75, 2))]

# data with other filter
data_table <- data[, `:=` (Value = round(Value, 2),
                    Variance = round(Variance, 2),
                    q25 = round(q25, 2),
                    q75 = round(q75, 2))]


## SERVER part of the app.####
# The server piece contains all reactive components.
shinyServer(function(input, output, session) {
  ##Reactive component of the sidebar using renderUI and uiOutput functions####
  ##This allows us to update the sidebar based on other inputs##
  
  # Input that applies to all ####
  # Select type of output
  # output$layoutInput <- renderUI({
  #   radioButtons("layoutInput","Output type", choices = c("Interactive plots", "Timing plots"),
  #                selected = "Interactive plots", inline = T)
  # })
  # Select levels or Cumulative
  output$cumulInput <- renderUI({
    sliderTextInput("cumulInput", "Cumulative*", choices = c('Y', 'N'),
      selected = 'N', width = '50%')
  })
  # Select weekly or monthly
  output$wkInput <- renderUI({
    sliderTextInput("wkInput", "Time interval", choices = c('Weekly', 'Monthly'),
                    selected = 'Monthly', width = '50%')
  })
  # Select a statistic
  output$statInput <- renderUI({
    selectInput("statInput","Statistic", choices = list_of_stats, multiple = F,
                selected = "Total")
  })
  # Select landings in rev or lbs
  output$metricInput <- renderUI({
    selectInput("metricInput", "Landings data", choices = list_of_metrics, multiple = F,
                selected = 'Exvessel revenue')
  })
  # Download button#####
  output$download_Table <- renderUI({
    tags$div(class = "actbutton",
             downloadButton("dlTable", "Download Data Table", class = "btn-primary"))
  })
  
  # Input that applies to "custom input" ####
  # Select management group
  output$mgrpInput <- renderUI({
    selectInput("mgrpInput", "Fishery groups", choices = list_of_species, multiple = T,
                       selected = c('Non-whiting groundfish: IFQ-bottom trawl'))
  })
  # select state
  output$regionInput <- renderUI({
    checkboxGroupInput("regionInput", "State", choices = c('All','California','Oregon','Washington'),
                       selected = c('All'),
                       inline = T)
  })
  
  # state dropdown for seasonality
  output$state1Input <- renderUI({
    selectInput("state1Input", "Filter by state", choices = c('All','California','Oregon','Washington'), multiple = T,
                selected = c('California','Oregon','Washington'))
  })
  # state dropdown for 2020 change
  # No longer using this filter (av 1/21/2021)
  # output$state2Input <- renderUI({
  #   selectInput("state2Input", "Filter by state", choices = c('All','California','Oregon','Washington'), multiple = T,
  #               selected = c('California','Oregon','Washington'))
  # })
  # Input that applies to "importance" ####
  # select proportion of revenue by state
  output$state_select <- renderUI({
      checkboxGroupInput("state_select", "", choices = c('All','California','Oregon','Washington'),
                         selected = c('Oregon'),
                         inline = T)
  })
  # output$state_prop <- renderUI({
  #   sliderInput("state_prop", label = "",
  #               min = 0, max = state_max, value = c(10, state_max), step = 10)
  # })
  output$state_prop <- renderUI({
    selectInput("state_prop", "Filter by percent contribution to state-wide fisheries revenue", 
                choices = c('0-5%', '5.1-10%', '> 10%'),
                multiple = F, selected = '> 10%')
  })
  
  # Input that applies to seasonality ####
  # Filter by proportion of revenue by month
  output$month_select <- renderUI({
    selectInput("month_select", "", choices = unique(data_m$select_month),
                multiple = F, selected = 'May')
  })
  
  # output$month_prop <- renderUI({
  #   sliderInput("month_prop", label = "",
  #               min = 0, max = month_max, value = c(20,month_max), step = 10)
  # })
  output$month_prop <- renderUI({
    selectInput("month_prop", "Filter by percent contribution by month to fisheries revenue", choices = c('0-5%', '5.1-10%', '10.1-15%', '15.1-20%', '> 20%'),
                multiple = F, selected = '> 20%')
  })
  # Input that applies to 2020 change ####
  # output$perc_change <- renderUI({
  #   sliderInput("perc_change", label = "",
  #               min = perc_min, max = perc_max, value = c(-20, 0), step = 20)
  # })
  # output$perc_change <- renderUI({
  #   selectInput("perc_change", "", choices = c('\u2265 35% decrease', '< 35% decrease', '< 35% increase', '\u2265 35% increase', 'Cannot be calculated'),
  #               multiple = F, selected = '\u2265 35% decrease')
  # })
  
  output$download_Figure <- renderUI({
    tags$div(class = "actbutton",
             downloadButton("dlFigure", "Download Plot", class = "btn-primary"))
  })
  
# Reactive Data component ####
  filtered <- reactive({
    if(input$filter_ops == "Importance") {
      req(input$statInput)
      
    data[(Statistic == input$statInput &
             Metric == input$metricInput &
             Cumulative == input$cumulInput &
             Interval == input$wkInput &
             State %in% c(input$state_select) &
             state_prop == input$state_prop
             )] %>%
        data.frame()
    }
    else if(input$filter_ops == "Seasonality") {
      data_m[(Statistic == input$statInput &
          Metric == input$metricInput &
          Cumulative == input$cumulInput &
          Interval == input$wkInput &
          State %in% c(input$state1Input) &
          select_month == input$month_select &
          month_prop == input$month_prop)]
    }
    # else if(input$filter_ops == '2020 change') {
    #   data[(Statistic == input$statInput &
    #              Metric == input$metricInput &
    #              Cumulative == input$cumulInput &
    #              Interval == input$wkInput &
    #              State %in% c(input$state2Input) &
    #              percchange == input$perc_change)]
    # }
    else if(input$filter_ops == "Custom output") {
      data[(Species %in% c(input$mgrpInput) &
          Statistic == input$statInput &
          Metric == input$metricInput &
          Cumulative == input$cumulInput &
          Interval == input$wkInput &
          State %in% c(input$regionInput))]
    }
    
  })

  filtered_dt <- reactive({
    filtered() %>%
    mutate(Value = round(Value, 2),
           Variance = round(Variance, 2),
           q25 = round(q25, 2),
           q75 = round(q75, 2))
  })
  #creating the dataframe for data table#####
  ##Use reactive to reactively filter the dataframe based on inputs
  
  dt_dat <- reactive({
    if(is.null(filtered_dt())){
      return()
    }
    if(input$wkInput == 'Monthly') {
    dat <- filtered_dt() %>%
      mutate(pre_date = format(pre_date, "%B"))
    } else {
      dat <- filtered_dt()
    }
    tabformatfun <- function(x) {
      rounding <- case_when(
        any(dat$Value < 1) ~ 2, 
        all(dat$unit == '') ~ 1, T ~ 0)
      dollar   <- ifelse(grepl('$', dat$ylab, fixed = T), '$', '')
      val = formatC(x, format = 'f', dig = rounding, big.mark = ',')
      return(val)
    }
    dat$Value <-    tabformatfun(dat$Value)
    dat$Variance <- tabformatfun(dat$Variance)
    dat$q25 <-      tabformatfun(dat$q25)
    dat$q75 <-      tabformatfun(dat$q75)
    
    valuetitle <- ifelse(any(dat$Statistic == ''), 'Value', as.character(unique(dat$Statistic)))
    vartitle <- ifelse(input$statInput %in% c('Total', ''), 'Variance',
                       ifelse(input$statInput == 'Median', 'Mean average deviation',
                              'Standard deviation'))
    
    # rename the columns 
    dat <-
      rename(dat,
             !!quo_name(valuetitle)       := Value,
             !!quo_name(vartitle)         := Variance,
             `Quartile: 25th`              = q25,
             `Quartile: 75th`              = q75,
              Date                         = pre_date,
              Unit                         = unit,
             `Completeness status`            = complete)
    
    alwaysexclude <- c('ylab','upper','lower','Type', 'Dates', 'Date_plot','no_pts', 'Dates_as_char',
                       'Cumulative','Interval', 'percdiff','state_prop','percchange', 'N_vss', 
                       'N_buy', 'percchange1', 'state_prop1', 'baseline_as_year', 'CONF')
    dat <- select(dat, colnames(dat)[apply(dat, 2, function(x) sum(x != '' & x != ' NA' & !is.na(x) & x != 'NA') > 0 )], 
                  -alwaysexclude) 
    
    return(dat)
  })
  
  # Validate function with custom error messages
  valfn <- reactive({
    # define cumulative message so we don't have to write it out over and over
    cumul <- input$cumulInput == 'Y' & 
                !input$metricInput %in% c('Exvessel revenue','Landed weight (mt)')
    cumul_m <- "Cumulative totals are only calculated for exvessel revenue and landed weight. Please adjust your selection."
    num <- input$statInput != 'Total' &
      input$metricInput %in% c('Number of vessels','Number of buyers')
    num_m <- "Mean and median are not calculated for the number of vessels or buyers. Please select total."
    atsea <- input$mgrpInput %in% c('Whiting: Mothership','Whiting: Catcher processor') &
      input$metricInput == 'Exvessel revenue'
    atsea_m <- "Ex-vessel revenue is not shown for the mothership or catcher-processor fleet."
    if(nrow(filtered()) == 0){
      if(input$filter_ops == 'Importance') {
        if(cumul) {
          return(cumul_m)
          } else if(num) {
            return(num_m)
          } else {
        return("Your selection yielded no results. Please choose another state or adjust the percent contribution level.")
          }
        } else if(input$filter_ops == 'Seasonality') {
          if(cumul) {
            return(cumul_m)
          } else if(num) {
            return(num_m)
           } else {
            return("Your selection yielded no results. Please choose another month or adjust the percent contribution level.")
              }
          # } else if(input$filter_ops == "2020 change"){
          #   if(cumul) {
          #     return(cumul_m)
          #   } else if(num) {
          #     return(num_m)
          #   } else {
          #   return("Your selection yielded no results. Please choose another percent change level.")
          #     }
          } else if(input$filter_ops == 'Custom output'){
            if(cumul) {
              return(cumul_m)
            } else if(num) {
              return(num_m)
            } else if(atsea) {
              return(atsea_m) 
           } else {
              return("Your selection yielded no results. Please choose another state or fishery.")
            }
          }
    }
  })
  

  
  lineColor<- c(
    '2015-2019' = 'lightgray',
    '2020' = 'deepskyblue2',
    '2021' = 'mediumblue',
    '2015-2019 Median' = 'red'
  )
  
  plot_size <- reactive({
    size <- filtered() %>%
      summarize(count = length(unique(ylab)))
    if (size$count > 6) {
      h <- 1600
    } else {
      h <- 800
    }
    #print(h)
  })
  
plot_title <- reactive({
  case_when(input$filter_ops == "Importance" ~
              paste('Fisheries that represent', input$state_prop, 'of annual ex-vessel revenue for', toString(input$state_select)),
            input$filter_ops == 'Seasonality' ~
              paste('Fisheries that represent', input$month_prop, 'of', input$month_select, 'ex-vessel revenue for', toString(input$state1Input)),
            # input$filter_ops == '2020 change' ~ 
            #   paste('Fisheries with a',  input$perc_change, 'in total ex-vessel revenue compared to 2014-2019'),
            T ~ '')
})



  # Plot
  output$plot <- renderPlotly({
    shiny::validate(valfn())
    ptsize = ifelse(input$wkInput == 'Weekly', .1, 1.5)
    main_plot <- ggplot(filtered(),
                        aes(x = Date_plot, y = Value, color = Type,  group = Year)) +
      scale_color_manual(values = lineColor, name = 'Time period') +
      theme_minimal() +
      theme(text = element_text(size = 12),
            axis.text = element_text(size = 8),
            strip.text = element_text(size = 10),
            axis.title.x = element_blank(),
            axis.title.y = element_text(size = 12),
            panel.spacing.y = unit(2, "lines"),
            plot.title = element_text(size = 12)) +
      scale_x_date(date_labels = '%b', date_breaks = "1 month") +
            # grey lines
            geom_line(data = filter(filtered(), Type == '2015-2019'), size = 0.6, mapping = aes(color = Type)) +
            # blue dotted line
            # geom_line(data = filter(filtered(), Year == 2020), aes(linetype = 'dotted'), color = "blue") +
            geom_line(data = filter(filtered(), Year == '2020'), linetype = 'dotted', color = "deepskyblue2") +
            # geom_line(data = filter(filtered(), Year == '2021'), aes(linetype = 'dotted'), color = "blue") +
            # draws thin blue and red lines through all points (thin line connects through suppressed data)
            geom_line(data = filter(filtered(), !is.na(Value) & Type != '2015-2019' & complete != 'uncertain'),
              mapping = aes(color = Type), linetype = 'F1', size = 0.1) +
            # draws thick blue and red lines through the "real points"
            geom_line(data = filter(filtered(), Type != '2015-2019' & complete != 'uncertain'),
              mapping = aes(color = Type), linetype = 'solid', size = 0.6) +
            # adds points to red and blue if set to monthly
            geom_point(data = filter(filtered(), no_pts == 0 & complete != 'uncertain'),
            mapping = aes(color = Type), size = ptsize) +
            facet_wrap(~ylab, scales = 'free', ncol = 2) +
            labs(y = paste(input$statInput, input$metricInput)) +
            scale_linetype_identity(
              name = "Reporting",
              breaks = c("solid", "F1", "dotted"),
              labels = c("Complete", "Suppressed for Confidentiality", "Incomplete"),
              guide = 'legend') +
           # guides(linetype = guide_legend(override.aes = list(size = c(1, .1, 1)))) +
            theme(legend.position='none') +
            expand_limits(y = 0) +
            #annotate("text", x = ymd('2001-04-01'), y = 9,
           #  label = whitingtext, hjust = 0, vjust = 1) +
            ggtitle(plot_title())

reg_plot <-  print(ggplotly(main_plot,
                            tooltip = 'Year',
                            height = plot_size(),
                            width = 850) %>%
                     layout(margin = list(b = 100, l = 50, r = 50, t = 100)))

  if(input$filter_ops == 'Custom output') {
  if('Whiting: Shorebased' %in% input$mgrpInput) {
  print(ggplotly(reg_plot,
                 tooltip = 'Year',
                 height = plot_size(),
                 width = 850) %>%
          layout(
            margin = list(b = 100, l = 50, r = 50, t = 150),
            title = list(
              text = 'Shorebased whiting: 2020/2021 cannot be shown by state because of confidentiality restrictions. 
              Select "All" for current whiting landing info. Historical landings by state are shown for context. 
              More info can be found on the Info page',
              font = list(
                size = 12,
                color = "#7f7f7f"
              )
            )))
} else {
  reg_plot
}} else {
  reg_plot
}
  })
  
  
  # end hover code from stack overflow
  
  ##Creating the data table for download
  output$table <- DT::renderDT({
    shiny::validate(valfn())
    datatable(dt_dat(), 
              rownames = FALSE,
    filter = "top",
      options = list(pageLength = 24, autoWidth = TRUE)
      )
  })
  
  output$dlTable <- downloadHandler(
    filename = function() { 'landings_tracker_2021.csv' },
    content = function(file) {
      table <- dt_dat()
      row.names(table) <- NULL
      table$source <- ""
      names(table)[names(table) == 'source'] <- "Sourced from the Landings Tracker 2021 application (http://dataexplorer.northwestscience.fisheries.noaa.gov/fisheye/landings_tracker/) maintained by NOAA Fisheriess NWFSC"
      write.csv(table, file)
    })
  
  #creating non-plotly plot for download
  plot_fun_download <- reactive({
    ptsize = ifelse(input$wkInput == 'Weekly', .1, 2.5)
    main_plot <- ggplot(filter(filtered(), Year %in% c(2020, 2021)),
                        aes(x = Date_plot, y = Value, color = Type,  group = Year)) +
      scale_color_manual(values = lineColor, name = 'Time period') +
      theme_minimal() +
      theme(text = element_text(size = 12),
            axis.text = element_text(size = 12),
            strip.text = element_text(size = 12),
            axis.title.x = element_blank(),
            axis.title.y = element_text(size = 12),
            panel.spacing.y = unit(2, "lines"),
            plot.title = element_text(size = 12),
            legend.text = element_text(size = 12)) +
      scale_x_date(date_labels = '%b', date_breaks = "1 month") +
      # # grey lines
       geom_line(data = filter(filtered(), Type == '2015-2019'), size = 0.6, mapping = aes(color = Type)) +
      # # blue dotted line
      # geom_line(data = filter(filtered(), Year == 2020), aes(linetype = 'dotted'), color = "blue") +
      # draws thin blue and red lines through all points (thin line connects through suppressed data)
      geom_line(data = filter(filtered(), !is.na(Value) & Type != '2015-2019' & complete != 'uncertain'),
                mapping = aes(color = Type, linetype = 'F1'), size = 0.2) +
      # draws thick blue and red lines through the "real points"
      geom_line(data = filter(filtered(), Type != '2015-2019' & complete != 'uncertain'),
                mapping = aes(color = Type, size = 'large'), size = 1) +
      # adds points to red and blue if set to monthly
      geom_point(data = filter(filtered(), no_pts == 0 & complete != 'uncertain'),
                 mapping = aes(color = Type), size = ptsize) +
      guides(linetype = FALSE) +
      facet_wrap(~ylab, scales = 'free', ncol = 2) +
      labs(y = paste(input$statInput, input$metricInput)) +
      # scale_linetype_identity(
      #   name = "Reporting",
      #   breaks = c("solid", "F1", "dotted"),
      #   labels = c("Complete", "Suppressed for Confidentiality", "Incomplete"),
      #   guide = 'legend') +
      # guides(linetype = guide_legend(override.aes = list(size = c(1, .1, 1)))) +
      #theme(legend.position='none') +
      expand_limits(y = 0) +
      #annotate("text", x = ymd('2001-04-01'), y = 9,
      #  label = whitingtext, hjust = 0, vjust = 1) +
      ggtitle(plot_title())
  })
  
  plotdl_sizew <- reactive({
    size <- filtered() %>%
      summarize(count = length(unique(ylab)))
    if (size$count > 1) {
      1476
    } else {
      984
    }
    #print(h)
  })
  
  plotdl_sizeh <- reactive({
    size <- filtered() %>%
      summarize(count = length(unique(ylab)))
    if (size$count == 1) {
      720
    } else if (size$count > 1 & size$count <= 4) {
      1080
    } else {
      1440
    }
    #print(h)
  })
  
  output$dlFigure <- downloadHandler(
    filename = function() {"landings_tracker.png"},
    content = function(file) {
      png(file, width = plotdl_sizew(), height = plotdl_sizeh(), res = 120)
      print(plot_fun_download())
      dev.off()
    })

})